use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use specta::Type;
use std::sync::{atomic::AtomicU32, Arc};
use tokio::sync::broadcast;
use uuid::Uuid;

#[derive(Clone)]
pub struct Notifications(
	// Keep this private and use `Node::emit_notification` or `Library::emit_notification` instead.
	broadcast::Sender<Notification>,
	// Counter for `NotificationId::Node(_)`. NotificationId::Library(_, _)` is autogenerated by the DB.
	Arc<AtomicU32>,
);

impl Notifications {
	#[allow(clippy::new_without_default)]
	pub fn new() -> Self {
		let (tx, _) = broadcast::channel(30);
		Self(tx, Arc::new(AtomicU32::new(0)))
	}

	pub fn subscribe(&self) -> broadcast::Receiver<Notification> {
		self.0.subscribe()
	}

	/// DO NOT USE THIS. Use `Node::emit_notification` or `Library::emit_notification` instead.
	pub fn _internal_send(&self, notification: Notification) {
		self.0.send(notification).ok();
	}

	pub fn _internal_next_id(&self) -> u32 {
		self.1.fetch_add(1, std::sync::atomic::Ordering::SeqCst)
	}
}

/// Represents a single notification.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct Notification {
	#[serde(flatten)]
	pub id: NotificationId,
	pub data: NotificationData,
	pub read: bool,
	pub expires: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Type, PartialEq, Eq)]
#[serde(tag = "type", content = "id", rename_all = "camelCase")]
pub enum NotificationId {
	Library(Uuid, u32),
	Node(u32),
}
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
#[serde(rename_all = "camelCase")]
pub enum NotificationKind {
	Info,
	Success,
	Error,
	Warning,
}

/// Represents the data of a single notification.
/// This data is used by the frontend to properly display the notification.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct NotificationData {
	pub title: String,
	pub content: String,
	pub kind: NotificationKind,
}
